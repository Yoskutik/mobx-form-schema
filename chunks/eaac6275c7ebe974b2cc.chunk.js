"use strict";(self.webpackChunk_yoskutik_react_vvm_docs=self.webpackChunk_yoskutik_react_vvm_docs||[]).push([[458],{2458:function(e,t,s){s.r(t),s.d(t,{default:function(){return q}});var n=s(2322),a=s(2784),i=s(9730),r=s(8434),o=s(3422),c=s(3853),l=s(1461),h=s(7896),d=s(6277),m=s(9075),p=s(7591),u=s(7764),x=s(3995),j=s(9222),b=s(5672);function f(e){return(0,b.Z)("MuiDivider",e)}(0,j.Z)("MuiDivider",["root","absolute","fullWidth","inset","middle","flexItem","light","vertical","withChildren","withChildrenVertical","textAlignRight","textAlignLeft","wrapper","wrapperVertical"]);let g=["absolute","children","className","component","flexItem","light","orientation","role","textAlign","variant"],v=e=>{let{absolute:t,children:s,classes:n,flexItem:a,light:i,orientation:r,textAlign:o,variant:c}=e;return(0,m.Z)({root:["root",t&&"absolute",c,i&&"light","vertical"===r&&"vertical",a&&"flexItem",s&&"withChildren",s&&"vertical"===r&&"withChildrenVertical","right"===o&&"vertical"!==r&&"textAlignRight","left"===o&&"vertical"!==r&&"textAlignLeft"],wrapper:["wrapper","vertical"===r&&"wrapperVertical"]},f,n)},w=(0,u.ZP)("div",{name:"MuiDivider",slot:"Root",overridesResolver:(e,t)=>{let{ownerState:s}=e;return[t.root,s.absolute&&t.absolute,t[s.variant],s.light&&t.light,"vertical"===s.orientation&&t.vertical,s.flexItem&&t.flexItem,s.children&&t.withChildren,s.children&&"vertical"===s.orientation&&t.withChildrenVertical,"right"===s.textAlign&&"vertical"!==s.orientation&&t.textAlignRight,"left"===s.textAlign&&"vertical"!==s.orientation&&t.textAlignLeft]}})(({theme:e,ownerState:t})=>(0,h.Z)({margin:0,flexShrink:0,borderWidth:0,borderStyle:"solid",borderColor:(e.vars||e).palette.divider,borderBottomWidth:"thin"},t.absolute&&{position:"absolute",bottom:0,left:0,width:"100%"},t.light&&{borderColor:e.vars?`rgba(${e.vars.palette.dividerChannel} / 0.08)`:(0,p.Fq)(e.palette.divider,.08)},"inset"===t.variant&&{marginLeft:72},"middle"===t.variant&&"horizontal"===t.orientation&&{marginLeft:e.spacing(2),marginRight:e.spacing(2)},"middle"===t.variant&&"vertical"===t.orientation&&{marginTop:e.spacing(1),marginBottom:e.spacing(1)},"vertical"===t.orientation&&{height:"100%",borderBottomWidth:0,borderRightWidth:"thin"},t.flexItem&&{alignSelf:"stretch",height:"auto"}),({ownerState:e})=>(0,h.Z)({},e.children&&{display:"flex",whiteSpace:"nowrap",textAlign:"center",border:0,"&::before, &::after":{content:'""',alignSelf:"center"}}),({theme:e,ownerState:t})=>(0,h.Z)({},t.children&&"vertical"!==t.orientation&&{"&::before, &::after":{width:"100%",borderTop:`thin solid ${(e.vars||e).palette.divider}`}}),({theme:e,ownerState:t})=>(0,h.Z)({},t.children&&"vertical"===t.orientation&&{flexDirection:"column","&::before, &::after":{height:"100%",borderLeft:`thin solid ${(e.vars||e).palette.divider}`}}),({ownerState:e})=>(0,h.Z)({},"right"===e.textAlign&&"vertical"!==e.orientation&&{"&::before":{width:"90%"},"&::after":{width:"10%"}},"left"===e.textAlign&&"vertical"!==e.orientation&&{"&::before":{width:"10%"},"&::after":{width:"90%"}})),y=(0,u.ZP)("span",{name:"MuiDivider",slot:"Wrapper",overridesResolver:(e,t)=>{let{ownerState:s}=e;return[t.wrapper,"vertical"===s.orientation&&t.wrapperVertical]}})(({theme:e,ownerState:t})=>(0,h.Z)({display:"inline-block",paddingLeft:`calc(${e.spacing(1)} * 1.2)`,paddingRight:`calc(${e.spacing(1)} * 1.2)`},"vertical"===t.orientation&&{paddingTop:`calc(${e.spacing(1)} * 1.2)`,paddingBottom:`calc(${e.spacing(1)} * 1.2)`})),O=a.forwardRef(function(e,t){let s=(0,x.Z)({props:e,name:"MuiDivider"}),{absolute:a=!1,children:i,className:r,component:o=i?"div":"hr",flexItem:c=!1,light:m=!1,orientation:p="horizontal",role:u="hr"!==o?"separator":void 0,textAlign:j="center",variant:b="fullWidth"}=s,f=(0,l.Z)(s,g),O=(0,h.Z)({},s,{absolute:a,component:o,flexItem:c,light:m,orientation:p,role:u,textAlign:j,variant:b}),Z=v(O);return(0,n.jsx)(w,(0,h.Z)({as:o,className:(0,d.Z)(Z.root,r),role:u,ref:t,ownerState:O},f,{children:i?(0,n.jsx)(y,{className:Z.wrapper,ownerState:O,children:i}):null}))}),Z=({children:e})=>(0,n.jsx)(o.Z,Object.assign({gap:2,sx:{display:"grid",gridTemplateColumns:{xs:"auto",md:"auto auto"}}},{children:e})),S=({item:e,children:t})=>(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(o.Z,Object.assign({sx:{mt:{xs:2,md:0}}},{children:(0,n.jsx)(i.EK,{children:e})})),(0,n.jsx)(c.ZP,Object.assign({container:!0,direction:"column",gap:2},{children:t}))]}),E=()=>(0,n.jsx)(O,{sx:{gridColumn:{md:"1 / 3"}}}),k=({text:e})=>(0,n.jsx)(i.Dx,{sx:{gridColumn:{md:"1 / 3"}},text:e,variant:"h4"}),K=({docs:e,examples:t})=>(0,n.jsxs)(r.Z,Object.assign({component:"p"},{children:["For better understanding see:",(0,n.jsx)(i.hh,{text:`@${e} docs`,id:`decorators.${e}`,page:"docs"})," /",(0,n.jsx)(i.hh,{text:`${t} examples`,id:t,page:"examples"}),"."]})),F=()=>{let e=(0,n.jsx)(K,{examples:"validation",docs:"validate"}),t=(0,n.jsx)(K,{examples:"observation",docs:"watch"});return(0,n.jsx)(i.ib,Object.assign({title:"ManualFormSchema",description:(0,n.jsxs)(r.Z,Object.assign({component:"p"},{children:[(0,n.jsx)(i.EK,{children:"ManualFormSchema"})," is base class. In order to create your schema you have to create a new class extended from this base class."]}))},{children:(0,n.jsxs)(Z,{children:[(0,n.jsx)(k,{text:"Static properties"}),(0,n.jsx)(E,{}),(0,n.jsxs)(S,Object.assign({item:"procted static config"},{children:[(0,n.jsxs)(r.Z,Object.assign({component:"p"},{children:["An object, that provides schema's configuration. This objects contains one field - ",(0,n.jsx)(i.EK,{children:"manual"}),". By default, the ",(0,n.jsx)(i.EK,{children:"manual"})," is equal to ",(0,n.jsx)(i.EK,{children:"false"}),". Which means that all the validation and observation will be called using ",(0,n.jsx)(i.EK,{children:"autorun"})," function. If you want to turn of such behaviour, switch this value to ",(0,n.jsx)(i.EK,{children:"true"}),"."]})),(0,n.jsx)(i.oP,{code:"class Schema extends FormSchema {\n  protected static config = {\n    manual: true,\n  };\n}"})]})),(0,n.jsx)(k,{text:"Static methods"}),(0,n.jsx)(E,{}),(0,n.jsxs)(S,Object.assign({item:"static create([initialData])"},{children:[(0,n.jsxs)(r.Z,Object.assign({component:"p"},{children:["An method that creates an instance of ",(0,n.jsx)(i.EK,{children:"ManualFormSchema"}),". In order to create one, you must use it."]})),(0,n.jsxs)(r.Z,Object.assign({component:"p"},{children:[(0,n.jsx)(i.EK,{children:"create"})," method makes your schema observable, so you don't have to call ",(0,n.jsx)(i.EK,{children:"makeObservable"})," function inside your schema's constructor. In case you want to create reactions in your schema, you should call it in the constructor, but usually you don't have to think about using it."]})),(0,n.jsxs)(r.Z,Object.assign({component:"p"},{children:["You can pass data into this function, which will be used to create the initial state of your form. If such object is not passed, the initial state will be created using initial values from schema's class. See",(0,n.jsx)(i.hh,{text:"@factory",id:""})," for better understanding."]}))]})),(0,n.jsx)(k,{text:"Getters"}),(0,n.jsx)(E,{}),(0,n.jsxs)(S,Object.assign({item:"get errors"},{children:[(0,n.jsx)(r.Z,Object.assign({component:"p"},{children:"An object that contains validation error messages of your form."})),e]})),(0,n.jsxs)(S,Object.assign({item:"get isValid"},{children:[(0,n.jsx)(r.Z,Object.assign({component:"p"},{children:"A boolean that tells whether your form is valid."})),e]})),(0,n.jsxs)(S,Object.assign({item:"get isChanged"},{children:[(0,n.jsx)(r.Z,Object.assign({component:"p"},{children:"An boolean that tells whether your form is changed."})),t]})),(0,n.jsxs)(S,Object.assign({item:"get presentation"},{children:[(0,n.jsx)(r.Z,Object.assign({component:"p"},{children:"An object that contains presentation of your form's data."})),(0,n.jsx)(K,{examples:"presentation",docs:"presentation"})]})),(0,n.jsx)(k,{text:"Methods"}),(0,n.jsx)(E,{}),(0,n.jsxs)(S,Object.assign({item:"validate([field])"},{children:[(0,n.jsx)(r.Z,Object.assign({component:"p"},{children:"You can validate a single property in your schema or validate its entirely. If you pass a field name to this function, only this property will be validated. If you don't, the form will be validated entirely."})),(0,n.jsxs)(r.Z,Object.assign({component:"p"},{children:["There's no need to call this function, if you don't set ",(0,n.jsx)(i.EK,{children:"config.manual"})," to ",(0,n.jsx)(i.EK,{children:"true"}),", because the validation will be applied automatically."]})),(0,n.jsxs)(r.Z,Object.assign({component:"p"},{children:["After this function is called, the ",(0,n.jsx)(i.EK,{children:"errors"})," object is updated."]})),(0,n.jsx)(r.Z,Object.assign({component:"p"},{children:"The function return the result of validation. If a name of property if passed the function return the result of its validators. If not, return boolean that tells whether the form is valid."})),e]})),(0,n.jsxs)(S,Object.assign({item:"checkChanges([field])"},{children:[(0,n.jsx)(r.Z,Object.assign({component:"p"},{children:"You can check if a single property is differs from the initial state or if there's any changes in the entire schema. If you pass a field name to this function, only this property will be checked. If you don't, the form will be checked entirely."})),(0,n.jsxs)(r.Z,Object.assign({component:"p"},{children:["There's no need to call this function, if you don't set ",(0,n.jsx)(i.EK,{children:"config.manual"})," to ",(0,n.jsx)(i.EK,{children:"true"}),", because the observation will be applied automatically."]})),(0,n.jsxs)(r.Z,Object.assign({component:"p"},{children:["After this function is called, the ",(0,n.jsx)(i.EK,{children:"isChanged"})," getter is updated."]})),(0,n.jsx)(r.Z,Object.assign({component:"p"},{children:"If property name is passed, will return is property changed. If not, will return is entire form is changed."})),e]})),(0,n.jsxs)(S,Object.assign({item:"getInitial(field)"},{children:[(0,n.jsx)(r.Z,Object.assign({component:"p"},{children:"A function, that returns the initial value of a single property in a schema."})),t]})),(0,n.jsxs)(S,Object.assign({item:"sync()"},{children:[(0,n.jsxs)(r.Z,Object.assign({component:"p"},{children:["A function, that saves the current state of your schema as the initial. And because the current state starts being initial, the ",(0,n.jsx)(i.EK,{children:"isChanged"})," getter starts to return ",(0,n.jsx)(i.EK,{children:"false"}),"."]})),t]})),(0,n.jsxs)(S,Object.assign({item:"reset()"},{children:[(0,n.jsxs)(r.Z,Object.assign({component:"p"},{children:["A function, that reset state from the current to the initial. And because the current state resets into initial, the ",(0,n.jsx)(i.EK,{children:"isChanged"})," getter starts to return ",(0,n.jsx)(i.EK,{children:"false"}),"."]})),t]}))]})}))},I=({decorator:e,code:t,children:s,linkId:a})=>(0,n.jsx)(i.ib,Object.assign({title:(0,n.jsxs)(i.EK,{children:["@",e]}),description:(0,n.jsxs)(n.Fragment,{children:[s,(0,n.jsxs)(r.Z,Object.assign({component:"p"},{children:["For better understanding see:",(0,n.jsx)(i.hh,{text:"example",id:`observation.${a}`}),"."]}))]})},{children:(0,n.jsx)(i.oP,{code:t})})),A=()=>(0,n.jsxs)(i.ib,Object.assign({title:"Watch",description:(0,n.jsxs)(r.Z,Object.assign({component:"p"},{children:["Applying ",(0,n.jsx)(i.EK,{children:"@watch"})," decorator and its modifiers to a property enables its observation. The schema saves the initial value of such properties, which makes possible to tell whether the property differs from the initial state. Also it makes possible to reset the property from the current state into initial and mark the current state as the initial."]}))},{children:[(0,n.jsxs)(I,Object.assign({decorator:"watch",linkId:"basic-usage---primitives",code:"import { FormSchema, watch } from '@yoskutik/mobx-form-schema';\n\nclass LoginInSchema extends FormSchema {\n  @watch username = '';\n\n  @watch password = '';\n}"},{children:[(0,n.jsxs)(r.Z,Object.assign({component:"p"},{children:["If you want to observe any primitive value, you should use the ",(0,n.jsx)(i.EK,{children:"@watch"})," decorator. This decorator enables observing your property and compares the current value with the initial one with reference comparison to understand whether it's changed."]})),(0,n.jsxs)(r.Z,Object.assign({component:"p"},{children:["Using ",(0,n.jsx)(i.EK,{children:"@watch"})," decorator applies ",(0,n.jsx)(i.EK,{children:"@observable"})," decorator on the property."]}))]})),(0,n.jsxs)(I,Object.assign({decorator:"watch.array",linkId:"arrays-of-primitives",code:"import { FormSchema, watch } from '@yoskutik/mobx-form-schema';\n\nclass Schema extends FormSchema {\n  @watch.array shallowObservableArray: string[] = [];\n}"},{children:[(0,n.jsxs)(r.Z,Object.assign({component:"p"},{children:["If you want to observe an arrays of primitive values, you should use the ",(0,n.jsx)(i.EK,{children:"@watch.array"})," decorator."]})),(0,n.jsxs)(r.Z,Object.assign({component:"p"},{children:["Using ",(0,n.jsx)(i.EK,{children:"@watch.array"})," decorator applies ",(0,n.jsx)(i.EK,{children:"@observable.shallow"})," decorator on the property. This decorator is supposed to be used on sets of primitive values, which means there's no need to use any other types of observation."]}))]})),(0,n.jsxs)(I,Object.assign({decorator:"watch.set",linkId:"sets-of-primitives",code:"import { FormSchema, watch } from '@yoskutik/mobx-form-schema';\n\nclass Schema extends FormSchema {\n  @watch.set shallowObservableSet = new Set<string>();\n}"},{children:[(0,n.jsxs)(r.Z,Object.assign({component:"p"},{children:["If you want to observe a set of primitive values, you should use the ",(0,n.jsx)(i.EK,{children:"@watch.set"})," decorator."]})),(0,n.jsxs)(r.Z,Object.assign({component:"p"},{children:["Using ",(0,n.jsx)(i.EK,{children:"@watch.set"})," decorator applies ",(0,n.jsx)(i.EK,{children:"@observable.shallow"})," decorator on the property. This decorator is supposed to be used on sets of primitive values, which means there's no need to use any other types of observation."]}))]})),(0,n.jsxs)(I,Object.assign({decorator:"watch.schema",linkId:"nested-schemas",code:"import { FormSchema, watch } from '@yoskutik/mobx-form-schema';\nimport { observable } from 'mobx';\n\nclass NestedSchema extends FormSchema {\n  @watch email = '';\n\n  @watch github = '';\n}\n\nclass Schema extends FormSchema {\n  @watch.schema contacts = NestedSchema.create();\n}"},{children:[(0,n.jsxs)(r.Z,Object.assign({component:"p"},{children:["If you want to observe a nested form schema, you should use the ",(0,n.jsx)(i.EK,{children:"@watch.schema"})," decorator."]})),(0,n.jsxs)(r.Z,Object.assign({component:"p"},{children:["Using ",(0,n.jsx)(i.EK,{children:"@watch.schema"})," decorator applies ",(0,n.jsx)(i.EK,{children:"@observable.ref"})," decorator on the property. And it's more preferable to make your nested schema observable by it's reference, because nested schema must decide on its own which properties should be observable. But if you need, you can set any other decorator."]}))]})),(0,n.jsxs)(I,Object.assign({decorator:"watch.schemasArray",linkId:"arrays-of-nested-schemas",code:"import { FormSchema, watch } from '@yoskutik/mobx-form-schema';\nimport { observable } from 'mobx';\n\nclass RelativeSchema extends FormSchema {\n  @watch email = '';\n\n  @watch github = '';\n}\n\nclass Schema extends FormSchema {\n  @watch.array relatives = [RelativeSchema.create()];\n}"},{children:[(0,n.jsxs)(r.Z,Object.assign({component:"p"},{children:["If you want to observe an array of nested form schemas, you should use the ",(0,n.jsx)(i.EK,{children:"@watch.schemasArray"})," decorator."]})),(0,n.jsxs)(r.Z,Object.assign({component:"p"},{children:["Using ",(0,n.jsx)(i.EK,{children:"@watch.schemasArray"})," decorator applies ",(0,n.jsx)(i.EK,{children:"@observable.shallow"})," decorator on the property. And it's more preferable to make your nested schema observable by it's reference, because nested schema must decide on its own which properties should be observable. But if you need, you can set any other decorator."]}))]})),(0,n.jsxs)(i.ib,Object.assign({title:(0,n.jsx)(i.EK,{children:"watch.configure"}),description:(0,n.jsxs)(r.Z,Object.assign({component:"p"},{children:["All the existing modifiers of ",(0,n.jsx)(i.EK,{children:"@watch"})," decorator must covers almost all of your needs. But in case you have to create some extra ordinary rules, you can use ",(0,n.jsx)(i.EK,{children:"watch.configure"})," function to create your own decorator."]}))},{children:[(0,n.jsx)(i.oP,{code:"watch.configure(compareFn, saveFn, restoreFn);"}),(0,n.jsxs)(r.Z,Object.assign({component:"p"},{children:[(0,n.jsx)(i.EK,{children:"watch.configure"})," function takes 3 paramets - a function, which tells how to compare current version of the structure with the previous one; a function which tells how to save structure as the initial state; and a function which tells how to restore a structure from the initial state."]})),(0,n.jsxs)(r.Z,Object.assign({component:"p"},{children:["For better understanding see:",(0,n.jsx)(i.hh,{text:"example",id:"observation.configurable-observation"}),"."]}))]}))]}));var C=s(3847),T=s(9571);let P=({id:e})=>(0,n.jsxs)(r.Z,Object.assign({component:"p"},{children:["For better understanding see:",(0,n.jsx)(i.hh,{text:"example",id:`validation.${e}`}),"."]})),$=()=>(0,n.jsxs)(i.ib,Object.assign({title:"Validate",description:(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(r.Z,Object.assign({component:"p"},{children:["Applying ",(0,n.jsx)(i.EK,{children:"@validate"})," decorator enables its validation. You have to pass your validation rules into this function. Each rule will be applied sequentially."]})),(0,n.jsxs)(r.Z,Object.assign({component:"p"},{children:["If validation fails, the validation error message appears in the ",(0,n.jsx)(i.EK,{children:"errors"})," object. If validation passes, the error message of a property deletes from ",(0,n.jsx)(i.EK,{children:"errors"})," object."]})),(0,n.jsxs)(r.Z,Object.assign({component:"p"},{children:["If there's any validation errors, the ",(0,n.jsx)(i.EK,{children:"isValid"})," getter will return false."]}))]})},{children:[(0,n.jsx)(i.ib,Object.assign({title:"Validation rules",description:(0,n.jsxs)(r.Z,Object.assign({component:"p"},{children:["The validation function is a function that receives 2 parameters - the current value of the property and the entire schema, and return a boolean or string value. If function returns"," "," ",(0,n.jsx)(i.EK,{children:"false"})," the validation is considered to passed. If function returns string, this string will be used as validation error message."]}))},{children:(0,n.jsx)(i.oP,{code:C})})),(0,n.jsxs)(i.ib,Object.assign({title:(0,n.jsx)(i.EK,{children:"@validate()"}),description:(0,n.jsx)(r.Z,Object.assign({component:"p"},{children:"Each validation rule is applied sequentially. If first rule is passed, then second is applied, and so on. And if all the rules are passed, the field is considered to be valid."}))},{children:[(0,n.jsx)(i.oP,{code:"import { FormSchema, validate } from '@yoskutik/mobx-form-schema';\nimport { observable } from 'mobx';\nimport { required, lengthBetween } from 'path/to/validators';\n\nexport const repeatedPassword = () => (repeated: string, schema: Schema) => {\n  if (repeated === schema.password) return false;\n  return 'Passwords are mismatched';\n};\n\nclass Schema extends FormSchema {\n  @validate(required(), lengthBetween(8, 32))\n  @observable password = '';\n\n  @validate(required(), repeatedPassword())\n  @observable repeatedPassword = '';\n}"}),(0,n.jsx)(P,{id:"basic-usage"})]})),(0,n.jsxs)(i.ib,Object.assign({title:(0,n.jsx)(i.EK,{children:"@validate().if()"}),description:(0,n.jsxs)(r.Z,Object.assign({component:"p"},{children:["You can make your validation conditional. To do that you must call ",(0,n.jsx)(i.EK,{children:"@validate().if()"})," "," decorator."]}))},{children:[(0,n.jsx)(i.oP,{code:T}),(0,n.jsx)(P,{id:"conditional-validation"})]}))]})),D=({id:e})=>(0,n.jsxs)(r.Z,Object.assign({component:"p"},{children:["For better understanding see:",(0,n.jsx)(i.hh,{text:"example",id:`initialization.${e}`}),"."]})),N=()=>(0,n.jsx)(i.ib,Object.assign({title:"Factory",description:(0,n.jsx)(r.Z,Object.assign({component:"p"},{children:"You can describe how the data, received from server, must be handled before it will be used."}))},{children:(0,n.jsxs)(i.ib,Object.assign({title:(0,n.jsx)(i.EK,{children:"@factory()"}),description:(0,n.jsxs)(r.Z,Object.assign({component:"p"},{children:["The function that is passed into factory receives 2 parameters - the current value of the object, that was passed into static ",(0,n.jsx)(i.EK,{children:"create"})," method; and this object entirely."]}))},{children:[(0,n.jsx)(i.oP,{code:"import { FormSchema, factory } from '@yoskutik/mobx-form-schema';\n\nconst createFullName = (_: unknown, schema: Schema) =>\n  `${schema.name} ${schema.surname}`;\n\nconst createName = (name: string) => name.toUpperCase();\n\nexport class Schema extends FormSchema {\n  @factory(createFullName)\n  fullName: string;\n\n  @factory(createName)\n  name: string;\n\n  surname: string;\n}\n\nconst schema = Schema.create({\n  name: 'Dmitrii',\n  surname: 'Aleksandrovich',\n});\n\nconsole.log(schema.name);     // DMITRII\nconsole.log(schema.surname);  // Aleksandrovich\nconsole.log(schema.fullName); // Dmitrii Aleksandrovich"}),(0,n.jsx)(D,{id:"basic-usage"})]}))}));var M=s(8193);let R=({id:e})=>(0,n.jsxs)(r.Z,Object.assign({component:"p"},{children:["For better understanding see:",(0,n.jsx)(i.hh,{text:"example",id:`presentation.${e}`}),"."]})),B=()=>(0,n.jsxs)(i.ib,Object.assign({title:"Presentation",description:(0,n.jsx)(r.Z,Object.assign({component:"p"},{children:"You can describe how the data must be handled before sending it to the server."}))},{children:[(0,n.jsxs)(i.ib,Object.assign({title:(0,n.jsx)(i.EK,{children:"@presentation()"})},{children:[(0,n.jsx)(i.oP,{code:"import { FormSchema, presentation } from '@yoskutik/mobx-form-schema';\nimport { format } from 'date-fns';\n\nconst presentOther = (_: unknown, schema: Schema) =>\n  schema.date.getFullYear() < 2023 ? 'less' : 'not less';\n\nconst presentMonth = (date: Date) => format(date, 'yyyy-MM');\n\nexport class Schema extends FormSchema {\n  @presentation(presentOther)\n  other: string;\n\n  @presentation(presentMonth)\n  date = new Date();\n}\n\nconst schema1 = Schema.create();\nconsole.log(schema1.other); // 'not less'\nconsole.log(schema1.date);  // '2023-05'\n\nconst schema2 = Schema.create({\n  date: new Date('2022-06-01T00:00:00.000Z'),\n});\nconsole.log(schema2.other); // 'less'\nconsole.log(schema2.date);  // '2022-05'"}),(0,n.jsx)(R,{id:"with-transformations"})]})),(0,n.jsx)(i.ib,Object.assign({title:(0,n.jsx)(i.EK,{children:"@presentation.hide"}),description:(0,n.jsx)(r.Z,Object.assign({component:"p"},{children:"If you want, you can hide some properties from the presentation of your form."}))},{children:(0,n.jsx)(i.oP,{code:M})}))]})),V=(0,a.memo)(()=>(0,n.jsxs)(i.LG,{children:[(0,n.jsx)(F,{}),(0,n.jsxs)(i.ib,Object.assign({title:"Decorators"},{children:[(0,n.jsx)($,{}),(0,n.jsx)(A,{}),(0,n.jsx)(N,{}),(0,n.jsx)(B,{})]}))]}));var q=V},8193:function(e){e.exports="import { presentation, FormSchema } from '@yoskutik/mobx-form-schema';\n\nexport class Schema extends FormSchema {\n  password = '12345678';\n\n  @presentation.hidden\n  repeatedPassword = '12345678';\n}\n\nconst schema = Schema.create();\nconsole.log(schema.presentation);\n// {\n//   password: '12345678',\n// }\n"},3847:function(e){e.exports="export const required = () => (value?: string) => {\n  if (value?.trim()) return false;\n  return 'The field is required';\n};\n\nexport const lengthBetween = (min: number, max: number) => (value: string) => {\n  if (value.length >= min && value.length <= max) return false;\n  if (value.length < min) return `Should be longer than ${min} characters`;\n  return `Should be shorter than ${max} characters`;\n};"},9571:function(e){e.exports="import { FormSchema, validate } from '@yoskutik/mobx-form-schema';\nimport { observable } from 'mobx';\nimport { required, email } from 'path/to/validators';\n\nconst shouldValidateName = (_name: string, schema: SignUpSchema) =>\n  schema.wantToShareName;\n\nclass SignUpSchema extends FormSchema {\n  @validate(email()).if(Boolean) // or .if((email) => !!email)\n  @observable email = '';\n\n  @validate(required()).if(shouldValidateName)\n  @observable name = '';\n\n  @observable wantToShareName = true;\n}"}}]);