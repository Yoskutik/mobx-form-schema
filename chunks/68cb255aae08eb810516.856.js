"use strict";(self.webpackChunk_yoskutik_mobx_form_schema_docs=self.webpackChunk_yoskutik_mobx_form_schema_docs||[]).push([[856],{9928:function(e,t){t.Z={page:"RlzX",link:"vzUU",referenceHighlighter:"ug4B"}},7856:function(e,t,r){r.r(t),r.d(t,{default:function(){return l}});var a=r(8993),i=r(1568),n={filename:"Create.ts",code:"import { FormSchema } from '@yoskutik/mobx-form-schema';\r\n\r\nexport class CreateSchema extends FormSchema {\r\n  prop1 = 'default value';\r\n\r\n  prop2 = 2;\r\n}\r\n\r\nconst schema = CreateSchema.create({\r\n  prop2: 3033,\r\n  // can't pass 'prop3' since, CreateSchema doesn't contain such property\r\n});\r\n\r\nconsole.log(schema.prop1); // 'default value'\r\nconsole.log(schema.prop2); // 3033\r\n"},c={filename:"OnInit.ts",code:"import { FormSchema, validate, watch } from '@yoskutik/mobx-form-schema';\r\nimport { reaction } from 'mobx';\r\n\r\nexport class OnInitSchema extends FormSchema {\r\n  @validate((prop1: number) => prop1 > 10)\r\n  @watch prop1 = 1;\r\n\r\n  @watch prop2 = 2;\r\n\r\n  protected onInit() {\r\n    reaction(() => this.prop1, () => {\r\n      console.log('prop1 is changed');\r\n    });\r\n\r\n    reaction(() => !this.errors.prop1, isValid => {\r\n      console.log('prop1 is', isValid ? 'valid' : 'not valid');\r\n    });\r\n  }\r\n}\r\n"},o=r(9928);let h=()=>(0,a.BX)(a.HY,{children:[(0,a.BX)(i.$0,{title:(0,a.BX)(a.HY,{children:["Static ",(0,a.tZ)(i.EK,{children:"create"})," method"]}),children:[(0,a.BX)(i.xv,{children:[(0,a.tZ)(i.EK,{children:"FormSchema.create"})," method is used to create an instance of FormSchema. You should only create your schemas with ",(0,a.tZ)(i.EK,{children:"FormSchema.create"})," and never with the ",(0,a.tZ)(i.EK,{children:"new"})," keyword. Otherwise, your schemas may start working incorrectly."]}),(0,a.tZ)(i.xv,{children:"API reference:"}),(0,a.tZ)(i.oP,{code:"static create<T extends FormSchema>(data?: TFactoryData<T>, isManual?: boolean): T;",className:o.Z.referenceHighlighter}),(0,a.BX)(i.xv,{children:[(0,a.tZ)(i.EK,{children:"FormSchema.create"})," method receives 2 arguments:"]}),(0,a.BX)(i.aV,{variant:"ol",children:[(0,a.BX)("li",{children:[(0,a.tZ)(i.EK,{children:"data"}),": used to initialize the schema with initial values;"]}),(0,a.BX)("li",{children:[(0,a.tZ)(i.EK,{children:"isManual"}),": must be used if you want to validate and check changes of your form manually."]})]}),(0,a.BX)(i.xv,{children:["The ",(0,a.tZ)(i.EK,{children:"data"})," argument must have the same keys as FormSchema. If you don't use the ",(0,a.tZ)(i.EK,{children:"@factory"})," decorator, values from the ",(0,a.tZ)(i.EK,{children:"data"})," object will be applied to the schemas by their names."]}),(0,a.BX)(i.xv,{children:["If ",(0,a.tZ)(i.EK,{children:"data"})," is not passed, is empty, or there's no value for a specific property in a schema, such a property will use a default value from the schema declaration."]}),(0,a.BX)(i.xv,{children:["In the ",(0,a.tZ)(i.EK,{children:"create"})," static method schemas:"]}),(0,a.BX)(i.aV,{children:[(0,a.BX)("li",{children:["All the methods and getters receive their decorators from MobX (e.g. ",(0,a.tZ)(i.EK,{children:"observable"}),", "," ",(0,a.tZ)(i.EK,{children:"computed"})," or ",(0,a.tZ)(i.EK,{children:"action"}),")."]}),(0,a.BX)("li",{children:["Schema initializes with data from the ",(0,a.tZ)(i.EK,{children:"data"})," object."]}),(0,a.tZ)("li",{children:"Schema creates reactions for automatic validation (if schema is not created in manual mode)."}),(0,a.BX)("li",{children:["Schema saves its initial value (if the ",(0,a.tZ)(i.EK,{children:"watch"})," decorator was used). And creates reactions for automatic change observation (if the schema is not created in manual mode)."]})]}),(0,a.tZ)(i.$0,{title:"Example",children:(0,a.tZ)(i.KE,{items:[n]})})]}),(0,a.BX)(i.$0,{title:(0,a.BX)(a.HY,{children:[(0,a.tZ)(i.EK,{children:"onInit"})," method"]}),children:[(0,a.BX)(i.xv,{children:["All the logic that is applied in the ",(0,a.tZ)(i.EK,{children:"create"})," static method is applied after the schema's constructor is called. Which means that you cannot apply some reaction for the utility getters, like ",(0,a.tZ)(i.EK,{children:"errors"})," or ",(0,a.tZ)(i.EK,{children:"changedProperties"}),". Also, if you use the ",(0,a.tZ)(i.EK,{children:"@watch"})," decorator, your properties won't be observable in the constructor."]}),(0,a.BX)(i.xv,{children:["But you can use the ",(0,a.tZ)(i.EK,{children:"onInit"})," protected method. This method is called right after the static ",(0,a.tZ)(i.EK,{children:"create"})," method is finished."]}),(0,a.tZ)(i.xv,{children:"API reference:"}),(0,a.tZ)(i.oP,{className:o.Z.referenceHighlighter,code:"protected onInit(): void;"}),(0,a.tZ)(i.$0,{title:"Example",children:(0,a.tZ)(i.KE,{items:[c]})})]})]});var l=h}}]);