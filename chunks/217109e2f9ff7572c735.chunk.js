"use strict";(self.webpackChunk_yoskutik_react_vvm_docs=self.webpackChunk_yoskutik_react_vvm_docs||[]).push([[185],{8185:function(e,n,s){s.r(n),s.d(n,{default:function(){return f}});var a=s(2322),t=s(2784),o=s(9730),i=s(8434),c=s(3847),r=s(9571);let h=()=>(0,a.jsxs)(o.ib,Object.assign({title:"Validation",description:(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(i.Z,Object.assign({component:"p"},{children:"To start using validation, you must write the validation rules yourself. A validation rule for a schema is simply a function that returns either a string or a boolean value. If the function returns false, validation is considered passed. And if a string or true - no. Moreover, the string passed in the validator becomes an error message."})),(0,a.jsx)(o.oP,{code:c})]})},{children:[(0,a.jsxs)(o.ib,Object.assign({title:"Basic usage",description:(0,a.jsxs)(i.Z,Object.assign({component:"p"},{children:["You can start apply the validation by using ",(0,a.jsx)(o.EK,{children:"@validate"})," decorator. You should pass validation rules into this function. Each rule will be applied sequentially. If any validation rule is not passed, other rules will not be used."]}))},{children:[(0,a.jsx)(o.oP,{code:"import { FormSchema, validate } from '@yoskutik/mobx-form-schema';\nimport { observable } from 'mobx';\nimport { required, lengthBetween } from 'path/to/validators';\n\nexport class SignUpSchema extends FormSchema {\n  @validate(required(), lengthBetween(4, 8))\n  @observable pinCode = '';\n}"}),(0,a.jsxs)(i.Z,Object.assign({component:"p"},{children:["To understand whether your form is valid you can use ",(0,a.jsx)(o.EK,{children:"isValid"})," getter. To get error messages of your form you can use ",(0,a.jsx)(o.EK,{children:"errors"})," getter."]})),(0,a.jsx)(o.oP,{code:"const schema = SignUpSchema.create();\n\nconsole.log(schema.pinCode);  // ''\nconsole.log(schema.errors);   // { pinCode: 'The field is required' }\nconsole.log(schema.isValid);  // false\n\nschema.pinCode = '123';\nconsole.log(schema.errors);   // { pinCode: 'Should be longer than 4 characters' }\nconsole.log(schema.isValid);  // false\n\nschema.pinCode = '1234';\nconsole.log(schema.errors);   // {}\nconsole.log(schema.isValid);  // true\n\nschema.pinCode = '123456789';\nconsole.log(schema.errors);   // { pinCode: 'Should be shorter than 8 characters' }\nconsole.log(schema.isValid);  // false"})]})),(0,a.jsxs)(o.ib,Object.assign({title:"Using entire schema",description:(0,a.jsx)(i.Z,Object.assign({component:"p"},{children:"Sometimes validation can be complicated, and depends not only on the current value of the field, but also on other values in the form. For example, the password confirmation field must match the password. Setting up such validation is also easy."}))},{children:[(0,a.jsx)(i.Z,Object.assign({component:"p"},{children:"The validator function accepts two parameters as input: the current value of the form and the scheme of the form. And the second parameter can just be used in such cases."})),(0,a.jsx)(o.oP,{code:"import { FormSchema, validate } from '@yoskutik/mobx-form-schema';\nimport { observable } from 'mobx';\nimport { required, lengthBetween } from 'path/to/validators';\n\nexport const repeatedPassword = () => (repeated: string, schema: SignUpSchema) => {\n  if (repeated === schema.password) return false;\n  return 'Passwords are mismatched';\n};\n\nclass SignUpSchema extends FormSchema {\n  @validate(required(), lengthBetween(8, 32))\n  @observable password = '';\n\n  @validate(required(), repeatedPassword())\n  @observable repeatedPassword = '';\n}"}),(0,a.jsxs)(i.Z,Object.assign({component:"p"},{children:["By default, all the validation applies using MobX's ",(0,a.jsx)(o.EK,{children:"autorun"})," function, which means that in the example of ",(0,a.jsx)(o.EK,{children:"repeatedPassword"})," the validation will be applied not only when ",(0,a.jsx)(o.EK,{children:"repeatedPassword"}),", but also when ",(0,a.jsx)(o.EK,{children:"password"})," is changed as well."]})),(0,a.jsx)(o.oP,{code:"const schema = SignUpSchema.create();\n\nschema.password = '12345678';\nconsole.log(schema.isValid); // false\nconsole.log(schema.errors);  // { repeatedPassword: 'Passwords are mismatched' }\n\nschema.repeatedPassword = '12345678';\nconsole.log(schema.isValid); // true\nconsole.log(schema.errors);  // {}\n\n// The validation is also applies when password is changed\nschema.password = 'another password';\nconsole.log(schema.isValid); // false\nconsole.log(schema.errors);  // { repeatedPassword: 'Passwords are mismatched' }\n"})]})),(0,a.jsxs)(o.ib,Object.assign({title:"Conditional validation",description:(0,a.jsx)(i.Z,Object.assign({component:"p"},{children:"There may be situations when there is a need to disable validation. Fields may be optional or may be hidden for some reason, and in some cases validation of some fields should be disabled depending on the values of other fields."}))},{children:[(0,a.jsxs)(i.Z,Object.assign({component:"p"},{children:["All this can be achieved as easily as possible. You just need to use the decorator ",(0,a.jsx)(o.EK,{children:"@validate(...).if(...)"}),", and pass a predictor function to it, by which the scheme will determine at what point to enable or disable validation."]})),(0,a.jsx)(o.oP,{code:r}),(0,a.jsxs)(i.Z,Object.assign({component:"p"},{children:["In the example above the validation for ",(0,a.jsx)(o.EK,{children:"email"})," will be applied it's not an empty string. This trick is helpful for validating non-required fields."]})),(0,a.jsxs)(i.Z,Object.assign({component:"p"},{children:["The condition of ",(0,a.jsx)(o.EK,{children:"name"})," property is based on the other property of schema. And ",(0,a.jsx)(o.EK,{children:"name"})," will be validated only, when ",(0,a.jsx)(o.EK,{children:"wantToShareName"})," is ",(0,a.jsx)(o.EK,{children:"true"}),"."]})),(0,a.jsx)(o.oP,{code:"const schema = SignUpSchema.create();\n\nconsole.log(schema.errors); // { name: 'The field is required' }\n\nschema.wantToShareName = false;\nconsole.log(schema.errors); // {}\n\nschema.email = 'not.valid.email';\nconsole.log(schema.errors); // { email: 'The email is not valid' }"})]})),(0,a.jsx)(o.ib,Object.assign({title:"Manual validation",description:(0,a.jsxs)(i.Z,Object.assign({component:"p"},{children:["As you may noticed, by default, all the validation is applied automatically. Each time the field or any data, which validation depends on, is updated the validation will be recalculated. You might want to turn off such behaviour. To do that, you must set ",(0,a.jsx)(o.EK,{children:"config"})," static object in your schema."]}))},{children:(0,a.jsx)(o.oP,{code:"import { FormSchema, validate } from '@yoskutik/mobx-form-schema';\nimport { observable } from 'mobx';\nimport { required, lengthBetween } from 'path/to/validators';\n\nexport class SignUpSchema extends FormSchema {\n  protected static config = {\n    manual: true,\n  };\n\n  @validate(required(), lengthBetween(4, 8))\n  @observable pinCode = '';\n}\n\nconst schema = SignUpSchema.create();\n\nconsole.log(schema.isValid); // true\n\nschema.validate('pinCode');\n// you can also call validate() to validate entire form\nconsole.log(schema.isValid); // false\nconsole.log(schema.errors);  // { pinCode: 'The field is required' }"})}))]}));var l=s(3007);let m=()=>(0,a.jsxs)(o.ib,Object.assign({title:"Observation",description:(0,a.jsx)(i.Z,Object.assign({component:"p"},{children:"Sometimes it may be useful to understand whether the form is different from the initial state. For example, if we want to disable form submit button, if its content remain the same."}))},{children:[(0,a.jsxs)(o.ib,Object.assign({title:"Basic usage - primitives",description:(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(i.Z,Object.assign({component:"p"},{children:["To start observing primitives values like strings or numbers, you should apply the ",(0,a.jsx)(o.EK,{children:"@watch"})," decorator to the needed property. With such decorator values from the current and the initial state are compared by their reference, which means ",(0,a.jsx)(o.EK,{children:"@watch"})," won't work with non-primitive structures."]})),(0,a.jsxs)(i.Z,Object.assign({component:"p"},{children:["With ",(0,a.jsx)(o.EK,{children:"@watch"})," the values from the current and the initial state are compared by their reference, which means ",(0,a.jsx)(o.EK,{children:"@watch"})," won't work with non-primitive structures. If you want to enable watching for objects, see the information below."]})),(0,a.jsxs)(i.Z,Object.assign({component:"p"},{children:["By default, ",(0,a.jsx)(o.EK,{children:"@watch"})," and all its modifiers make the property observable, so instead of using ",(0,a.jsx)(o.EK,{children:"@watch @observable"})," you can just use ",(0,a.jsx)(o.EK,{children:"@watch"}),". But you need to, you can freely use it with any other modification of ",(0,a.jsx)(o.EK,{children:"@observable"})," decorator, such as ",(0,a.jsx)(o.EK,{children:"@observable.ref"})," or ",(0,a.jsx)(o.EK,{children:"observable.shallow"}),"."]}))]})},{children:[(0,a.jsx)(o.oP,{code:"import { FormSchema, watch } from '@yoskutik/mobx-form-schema';\n\nexport class UserSchema extends FormSchema {\n  @watch name = '';\n\n  @watch surname = '';\n}\n\nconst schema = UserSchema.create();\n\nschema.name = 'New Name';\nconsole.log(schema.isChanged);                // false\nconsole.log(schema.name);                     // 'New Name'\nconsole.log(schema.getInitial('name'));  // ''\n\n// or call `checkChanges()` to check entire schema\nschema.checkChanges('name');\nconsole.log(schema.isChanged);                // true"}),(0,a.jsxs)(i.Z,Object.assign({component:"p"},{children:["And now you can use the ",(0,a.jsx)(o.EK,{children:"isChanged"})," getter to know whether any property of the form is changed. And also you can use ",(0,a.jsx)(o.EK,{children:"getInitial"})," method to get the initial value of any property."]})),(0,a.jsx)(o.oP,{code:"const schema = UserSchema.create();\n\nconsole.log(schema.isChanged);                // false\n\nschema.name = 'New Name';\nconsole.log(schema.isChanged);                // true\nconsole.log(schema.getInitial('name'));  // ''\n\nschema.name = '';\nconsole.log(schema.isChanged);                // false"}),(0,a.jsx)(i.Z,Object.assign({component:"p"},{children:"And it's even more useful, when the form is pre-filled."})),(0,a.jsx)(o.oP,{code:"const schema = UserSchema.create({\n  name: 'Initial name',\n  surname: 'Initial surname',\n});\n\nconsole.log(schema.isChanged); // false\nconsole.log(schema.name);      // 'Initial name'\nconsole.log(schema.surname);   // 'Initial surname'\n\nschema.name = 'Changed name';\nconsole.log(schema.isChanged); // true\nconsole.log(schema.getInitial('name'));  // 'Initial name'\n\nschema.name = 'Initial name';\nconsole.log(schema.isChanged) // false"})]})),(0,a.jsx)(o.ib,Object.assign({title:"Arrays of primitives",description:(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(i.Z,Object.assign({component:"p"},{children:"Observing arrays of primitives may be useful, for example, if you have fields with multi choice, or an extendable list of items."})),(0,a.jsxs)(i.Z,Object.assign({component:"p"},{children:["If you want to observe an array of primitive values you can use ",(0,a.jsx)(o.EK,{children:"@watch.array"})," decorator. And now, even if you pass ",(0,a.jsx)("b",{children:"new"})," array with exact same content, the schema will understand, that it is not changed."]}))]})},{children:(0,a.jsx)(o.oP,{code:"import { FormSchema, watch } from '@yoskutik/mobx-form-schema';\nimport { observable } from 'mobx';\n\nexport class CVSchema extends FormSchema {\n  @observable.shallow\n  @watch.array skills: string[] = [];\n}\n\nconst schema = CVSchema.create({\n  skills: ['JavaScript', 'HTML'],\n});\n\nconsole.log(schema.isChanged); // false\n\nschema.skills.push('CSS');\nconsole.log(schema.isChanged); // true\n\nschema.skills.pop();\nconsole.log(schema.isChanged); // false\n\n// The array is new, but its content the same as in initial one\nschema.skills = ['JavaScript', 'HTML'];\nconsole.log(schema.isChanged); // false"})})),(0,a.jsx)(o.ib,Object.assign({title:"Sets of primitives",description:(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(i.Z,Object.assign({component:"p"},{children:"Observing sets may be as useful as observing arrays. But with a little difference. Sometimes the order of items in the list doesn't matter. In such scenarios, it's better to use sets instead of arrays."})),(0,a.jsxs)(i.Z,Object.assign({component:"p"},{children:["If you want to observe a set of primitive values you can use ",(0,a.jsx)(o.EK,{children:"@watch.set"})," decorator. And now, even if you pass ",(0,a.jsx)("b",{children:"new"})," set with exact same content, the schema will understand, that it is not changed."]}))]})},{children:(0,a.jsx)(o.oP,{code:"import { FormSchema, watch } from '@yoskutik/mobx-form-schema';\n\nexport class CVSchema extends FormSchema {\n  @watch.set skills = new Set<string>();\n}\n\nconst schema = CVSchema.create({\n  skills: new Set(['JavaScript', 'HTML']),\n});\n\nconsole.log(schema.isChanged); // false\n\nschema.skills.add('CSS');\nconsole.log(schema.isChanged); // true\n\nschema.skills.delete('CSS');\nconsole.log(schema.isChanged); // false\n\n// The set is new, but its content the same as in initial one\nschema.skills = new Set(['JavaScript', 'HTML']);\nconsole.log(schema.isChanged); // false"})})),(0,a.jsxs)(o.ib,Object.assign({title:"Nested schemas",description:(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(i.Z,Object.assign({component:"p"},{children:"If you form start becoming too big, you may decide to create a logical block of data inside your schema. But if you use a simple object to do that, you'll lose all possible features, that schema provides, such as validation or observation. But if you use nested schema, all these features will be available."})),(0,a.jsxs)(i.Z,Object.assign({component:"p"},{children:["In this case you can use ",(0,a.jsx)(o.EK,{children:"@watch.schema"})," decorator. And now, even if you pass ",(0,a.jsx)("b",{children:"new"})," array with exact same content, the schema will understand, that it is not changed."]}))]})},{children:[(0,a.jsx)(o.oP,{code:"import { FormSchema, watch } from '@yoskutik/mobx-form-schema';\nimport { observable } from 'mobx';\n\nexport class NestedSchema extends FormSchema {\n  @watch field = 0;\n}\n\nexport class SuperSchema extends FormSchema {\n  @watch.schema nested = NestedSchema.create();\n}\n\nconst schema = SuperSchema.create();\n\nconsole.log(schema.isChanged); // false\n\nschema.nested.field++;\nconsole.log(schema.isChanged); // true\n\nschema.nested.field--;\nconsole.log(schema.isChanged); // false\n\n// The schema is new, but its content the same as in initial one\nschema.nested = NestedSchema.create();\nconsole.log(schema.isChanged); // false"}),(0,a.jsxs)(i.Z,Object.assign({component:"p"},{children:["Also, with nested schemas you can reset only the nested schema instead of resetting the entire schema. For example, if you have a CV form and a block for the contacts there is a nested schema, you can add an opportunity to reset just the contacts block. You can see the example of it",(0,a.jsx)(o.hh,{href:"https://github.com/Yoskutik/mobx-form-schema/blob/master/examples/src/examples/Example6/Example6.tsx",text:"here"}),"."]}))]})),(0,a.jsx)(o.ib,Object.assign({title:"Arrays of nested schemas",description:(0,a.jsxs)(i.Z,Object.assign({component:"p"},{children:["For the same reasons why it is useful to use nested schemas, it can be use to use arrays of nested schemas. But to do that, you have to apply the other decorator - ",(0,a.jsx)(o.EK,{children:"@watch.schemasArray"}),". And you guessed right, even if you pass ",(0,a.jsx)("b",{children:"new"})," array with exact same content, schema will understand, that it is not changed."]}))},{children:(0,a.jsx)(o.oP,{code:"import { FormSchema, watch } from '@yoskutik/mobx-form-schema';\n\nexport class NestedSchema extends FormSchema {\n  @watch field = 0;\n}\n\nexport class SuperSchema extends FormSchema {\n  @watch.schema nested = [NestedSchema.create(), NestedSchema.create()];\n}\n\nconst schema = SuperSchema.create();\n\nconsole.log(schema.isChanged); // false\n\nschema.nested[0].field++;\nconsole.log(schema.isChanged); // true\n\nschema.nested[0].field--;\nconsole.log(schema.isChanged); // false\n\n// The array is new, but its content the same as in initial one\nschema.nested = [NestedSchema.create(), NestedSchema.create()];\nconsole.log(schema.isChanged); // false"})})),(0,a.jsxs)(o.ib,Object.assign({title:"Configurable observation",description:(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(i.Z,Object.assign({component:"p"},{children:["Basically, ",(0,a.jsx)(o.EK,{children:"watch"}),", ",(0,a.jsx)(o.EK,{children:"watch.set"}),", ",(0,a.jsx)(o.EK,{children:"watch.array"})," "," ",(0,a.jsx)(o.EK,{children:"watch.schema"})," and ",(0,a.jsx)(o.EK,{children:"watch.schemasArray"})," can cover most of your need. But, if you need to use any non-primitive value, you can use ",(0,a.jsx)(o.EK,{children:"watch.configure"})," method to create your own decorator."]})),(0,a.jsx)(l.Z,Object.assign({severity:"info"},{children:"Please make sure that the need for a new decorator is justified. Perhaps if you change your approach, existing decorators will be enough."})),(0,a.jsx)(i.Z,Object.assign({component:"p"},{children:"The example below present observation rule for observing only the second value in the array. That means, that the schema will be considered changed only if the second value is changed."}))]})},{children:[(0,a.jsx)(o.oP,{code:"import { FormSchema, watch } from '@yoskutik/mobx-form-schema';\n\nconst customDecorator = watch.configure(\n  (newValue, oldValue) => newValue[1] === oldValue[1],\n  (newValue) => newValue.slice(),\n  (newValue) => newValue.slice(),\n);\n\nexport class Schema extends FormSchema {\n  @customDecorator nested: [string, number] = ['field', 0];\n}\n\nconst schema = Schema.create();\n\nconsole.log(schema.isChanged); // false\n\nschema.nested[0] = 'other value';\nconsole.log(schema.isChanged); // false\n\nschema.nested[1]++;\nconsole.log(schema.isChanged); // true\n\nschema.nested[1]--;\nconsole.log(schema.isChanged); // false\n\n// The array is new, but the second item's content the same as in initial one\nschema.nested = ['', 0];\nconsole.log(schema.isChanged); // false"}),(0,a.jsxs)(i.Z,Object.assign({component:"p"},{children:[(0,a.jsx)(o.EK,{children:"watch.configure"})," function receives 3 arguments. The first one tells how the value must be compared with the initial version. The second one tells how the value must be save into the initial state. And the third one tells how to reset the value from the initial state. Usually, you have make a copy of your object in the second and third functions, to avoid changes in the initial state, when updating the current state."]}))]})),(0,a.jsxs)(o.ib,Object.assign({title:"Reset and syncronization",description:(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(i.Z,Object.assign({component:"p"},{children:["In order to understand that form was changed, the schema must contain the information about the initial state. And due to that fact, there's an opportunity to reset your form into the initial state. To do that you can use ",(0,a.jsx)(o.EK,{children:"reset"})," method."]})),(0,a.jsxs)(i.Z,Object.assign({component:"p"},{children:["Also you can save the current state of the schema as the initial one. To do that, you can use ",(0,a.jsx)(o.EK,{children:"sync"})," method."]}))]})},{children:[(0,a.jsx)(o.oP,{code:"import { FormSchema, watch } from '@yoskutik/mobx-form-schema';\nimport { observable } from 'mobx';\n\nexport class UserContactsSchema extends FormSchema {\n  @watch email = '';\n\n  @watch github = '';\n}\n\nexport class UserSchema extends FormSchema {\n  @watch name = '';\n\n  @watch.array skills: string[] = [];\n\n  @watch.schema contacts = UserContactsSchema.create();\n}"}),(0,a.jsx)(i.Z,Object.assign({component:"p"},{children:"No matter how complex your schema is, there is an opportunity to reset it. In the example above the schema contains a primitive value, an array and a nested schema. And resetting the parent schema will reset the nested one. As well as all the over properties in the schema."})),(0,a.jsx)(o.oP,{code:"const schema = UserSchema.create({\n  name: 'Dmitrii Aleksandrovich',\n  skills: ['JS', 'CSS', 'HTML'],\n  contacts: UserContactsSchema.create({\n    email: 'yoskutik@gmail.com',\n    github: 'https://github.com/Yoskutik',\n  }),\n});\n\nschema.name = 'Dmitrii';\nschema.skills.pop();\nschema.contacts.email = 'intruder@malicious.com';\n\nconsole.log(schema.isChanged);                    // true\nconsole.log(schema.getInitial('name'));           // 'Dmitrii Aleksandrovich'\nconsole.log(schema.getInitial('skills'));         // ['JS', 'CSS', 'HTML']\nconsole.log(schema.getInitial('contacts').email); // 'yoskutik@gmail.com'\n\n// Resetting schema into initial state\nschema.reset();\nconsole.log(schema.isChanged);                    // false\nconsole.log(schema.name);                         // 'Dmitrii Aleksandrovich'\nconsole.log(schema.skills);                       // ['JS', 'CSS', 'HTML']\nconsole.log(schema.contacts.email);               // 'yoskutik@gmail.com'\n\nschema.name = 'Dmitrii';\nschema.skills.pop();\nschema.contacts.email = 'intruder@malicious.com';\nconsole.log(schema.isChanged);                    // true\n\n// Saving current state as the initial\nschema.sync();\nconsole.log(schema.isChanged);                    // false\nconsole.log(schema.getInitial('name'));           // 'Dmitrii'\nconsole.log(schema.getInitial('skills'));         // ['JS', 'CSS']\nconsole.log(schema.getInitial('contacts').email); // 'intruder@malicious.com'"})]})),(0,a.jsx)(o.ib,Object.assign({title:"Manual observation",description:(0,a.jsxs)(i.Z,Object.assign({component:"p"},{children:["By default, all the observation applied automatically using ",(0,a.jsx)(o.EK,{children:"autorun"})," function from MobX. But if you want to turn off such behaviour, you have to set the configuration of your form."]}))},{children:(0,a.jsx)(o.oP,{code:"import { FormSchema, watch } from '@yoskutik/mobx-form-schema';\n\nexport class UserSchema extends FormSchema {\n  protected static config = {\n    manual: true,\n  };\n\n  @watch name = '';\n\n  @watch surname = '';\n}\n\nconst schema = UserSchema.create({\n  name: 'Dmitrii',\n  surname: 'Aleksandrovich',\n});\n\nschema.name = 'Vasiliy';\nconsole.log(schema.name);                // 'Vasiliy'\nconsole.log(schema.getInitial('name'));   // 'Dmitrii'\nconsole.log(schema.isChanged);           // false\n\nschema.checkChanges('name');\nconsole.log(schema.isChanged);           // true"})}))]})),d=()=>(0,a.jsxs)(o.ib,Object.assign({title:"Initialization",description:(0,a.jsxs)(i.Z,Object.assign({component:"p"},{children:["To create an instance of ",(0,a.jsx)("i",{children:"MobX Form Schema"})," you have to call static method ",(0,a.jsx)(o.EK,{children:"create"}),". This method can be called without any data or with a data, that will be used in the initialization process. By default, data from the passed object is applied without any transformations."]}))},{children:[(0,a.jsxs)(o.ib,Object.assign({title:"Basic usage"},{children:[(0,a.jsx)(i.Z,Object.assign({component:"p"},{children:"There's 2 ways to set the initial values for your form - you can set the value in the schema class, and you can pass them to the create function. And usually to create a pre-filled form, you will pass the data into create method."})),(0,a.jsx)(i.Z,Object.assign({component:"p"},{children:"In MobX, you have to initialize your property with any value if you want to make the observable, which is why you also have to create initial values in your schema."})),(0,a.jsx)(o.oP,{code:"import { FormSchema } from '@yoskutik/mobx-form-schema';\n\nexport class Schema extends FormSchema {\n  field = 0;\n}\n\nconst schema1 = Schema.create();\nconsole.log(schema1.field);   // 0\n\nconst schema2 = Schema.create({ field: 100 });\nconsole.log(schema2.field);   // 100"})]})),(0,a.jsxs)(o.ib,Object.assign({title:"With transformations",description:(0,a.jsxs)(i.Z,Object.assign({component:"p"},{children:["Sometimes the data that is stored on the server is not very useful in the work of the frontend, until they are preprocessed. For example, dates from the server will always be passed as a string. But at the same time, it may be more convenient to work with them when they are an object of the ",(0,a.jsx)(o.EK,{children:"Date"})," class."]}))},{children:[(0,a.jsx)(i.Z,Object.assign({component:"p"},{children:"You can do this:"})),(0,a.jsx)(o.oP,{code:"export class Schema extends FormSchema {\n  date = new Date();\n}\n\nconst data = await axios.post(...);\n\nconst schema = Schema.create({\n  ...data,\n  date: new Date(data.date),\n});"}),(0,a.jsx)(i.Z,Object.assign({component:"p"},{children:"This is a working approach, but I would not say that it is beautiful. And also in this case, you have to use the rest operator, and this adds odd calculations, which can be avoided."})),(0,a.jsxs)(i.Z,Object.assign({component:"p"},{children:["After all, you can specify in the scheme itself how to initialize your fields. To do this, you can use the ",(0,a.jsx)(o.EK,{children:"@factory"})," decorator."]})),(0,a.jsx)(o.oP,{code:"import { FormSchema, factory } from '@yoskutik/mobx-form-schema';\n\nexport class Schema extends FormSchema {\n  @factory(realDate => new Date(realDate))\n  realDate: Date;\n\n  stringDate: string;\n}\n\nconst schema = Schema.create({\n  realDate: '2023-05-25T10:00:00.000Z',\n  stringDate: '2023-05-25T10:00:00.000Z',\n});\n\nconsole.log(schema.realDate instanceof Date);    // true\nconsole.log(schema.stringDate instanceof Date);  // false"}),(0,a.jsx)(i.Z,Object.assign({component:"p"},{children:"And you all can use the entire object in the factory function, in case the initial value of one field is somehow depends on the value of other field."})),(0,a.jsx)(o.oP,{code:"import { FormSchema, factory } from '@yoskutik/mobx-form-schema';\n\nconst createFullName = (_: unknown, schema: Schema) =>\n  `${schema.name} ${schema.surname}`;\n\nexport class Schema extends FormSchema {\n  @factory(createFullName)\n  fullName: string;\n\n  name: string;\n\n  surname: string;\n}\n\nconst schema = Schema.create({\n  name: 'Dmitrii',\n  surname: 'Aleksandrovich',\n});\n\nconsole.log(schema.name);     // 'Dmitrii'\nconsole.log(schema.surname);  // 'Aleksandrovich'\nconsole.log(schema.fullName); // 'Dmitrii Aleksandrovich'"})]}))]}));var u=s(8193);let p=()=>(0,a.jsxs)(o.ib,Object.assign({title:"Presentation",description:(0,a.jsx)(i.Z,Object.assign({component:"p"},{children:"Each schema has its representation. And it's not about the UI. Just as we preprocess data from the server in order to use it conveniently, we may need the ability to reverse convert the data so that it can be properly stored on the server."}))},{children:[(0,a.jsxs)(o.ib,Object.assign({title:"Basic usage"},{children:[(0,a.jsxs)(i.Z,Object.assign({component:"p"},{children:["You can get a representation of the form in the ",(0,a.jsx)(o.EK,{children:"presentation"})," getter. By default, this getter provides all data from the form with except the utility data and methods."]})),(0,a.jsx)(o.oP,{code:"import { FormSchema } from '@yoskutik/mobx-form-schema';\n\nexport class Schema extends FormSchema {\n  field = 0;\n}\n\nconst schema = Schema.create();\nconsole.log(schema.presentation);   // { field: 0 }"})]})),(0,a.jsx)(o.ib,Object.assign({title:"With transformations",description:(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(i.Z,Object.assign({component:"p"},{children:["Imagine you may have a ",(0,a.jsx)(o.EK,{children:"Date"})," object in your schema, and this object must be used in your components. But you backend should must receive the string of format ",(0,a.jsx)(o.EK,{children:"yyyy-mm"}),". And this is when the presentation can really help you."]})),(0,a.jsxs)(i.Z,Object.assign({component:"p"},{children:["To create a transformation function for a property, use ",(0,a.jsx)(o.EK,{children:"presentation"})," decorator."]}))]})},{children:(0,a.jsx)(o.oP,{code:"import { presentation, FormSchema } from '@yoskutik/mobx-form-schema';\nimport { format } from 'date-fns';\n\nexport class Schema extends FormSchema {\n  @presentation(value => `@${value}`)\n  username = 'yoskutik';\n\n  @presentation(value => format(value, 'yyyy-MM'))\n  month = new Date();\n\n  name = 'Name';\n}\n\nconst schema = Schema.create();\nconsole.log(schema.presentation);\n// {\n//   username: '@yoskutik',\n//   month: '2023-05',\n//   name: 'Name',\n// }\n\n// But the real values remain the same\nconsole.log(schema.username);     // 'yoskutik'\nconsole.log(schema.month);        // Fri May 26 2023 00:00:00 GMT+0000 (Eastern European Summer Time)\nconsole.log(schema.name);         // 'Name'"})})),(0,a.jsx)(o.ib,Object.assign({title:"Hidden properties",description:(0,a.jsxs)(i.Z,Object.assign({component:"p"},{children:["If you want to completely remove the property from the presentation of your form you can use ",(0,a.jsx)(o.EK,{children:"presentation.hidden"})," decorator."]}))},{children:(0,a.jsx)(o.oP,{code:u})}))]})),g=(0,t.memo)(()=>(0,a.jsxs)(o.LG,{children:[(0,a.jsx)(h,{}),(0,a.jsx)(m,{}),(0,a.jsx)(d,{}),(0,a.jsx)(p,{})]}));var f=g},8193:function(e){e.exports="import { presentation, FormSchema } from '@yoskutik/mobx-form-schema';\n\nexport class Schema extends FormSchema {\n  password = '12345678';\n\n  @presentation.hidden\n  repeatedPassword = '12345678';\n}\n\nconst schema = Schema.create();\nconsole.log(schema.presentation);\n// {\n//   password: '12345678',\n// }\n"},3847:function(e){e.exports="export const required = () => (value?: string) => {\n  if (value?.trim()) return false;\n  return 'The field is required';\n};\n\nexport const lengthBetween = (min: number, max: number) => (value: string) => {\n  if (value.length >= min && value.length <= max) return false;\n  if (value.length < min) return `Should be longer than ${min} characters`;\n  return `Should be shorter than ${max} characters`;\n};"},9571:function(e){e.exports="import { FormSchema, validate } from '@yoskutik/mobx-form-schema';\nimport { observable } from 'mobx';\nimport { required, email } from 'path/to/validators';\n\nconst shouldValidateName = (_name: string, schema: SignUpSchema) =>\n  schema.wantToShareName;\n\nclass SignUpSchema extends FormSchema {\n  @validate(email()).if(Boolean) // or .if((email) => !!email)\n  @observable email = '';\n\n  @validate(required()).if(shouldValidateName)\n  @observable name = '';\n\n  @observable wantToShareName = true;\n}"}}]);