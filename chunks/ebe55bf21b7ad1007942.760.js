"use strict";(self.webpackChunk_yoskutik_mobx_form_schema_docs=self.webpackChunk_yoskutik_mobx_form_schema_docs||[]).push([[760],{9928:function(e,r){r.Z={page:"RlzX",link:"vzUU",referenceHighlighter:"ug4B"}},2760:function(e,r,a){a.r(r),a.d(r,{default:function(){return f}});var t=a(8993),n=a(1568),c={filename:"WatchSchema.ts",code:"import { FormSchema, watch } from '@yoskutik/mobx-form-schema';\r\nimport { runInAction } from 'mobx';\r\n\r\nexport class WatchSchema extends FormSchema {\r\n  @watch prop1 = 1;\r\n\r\n  @watch prop2 = 2;\r\n}\r\n\r\nconst schema = WatchSchema.create();\r\nconsole.log(schema.isChanged, schema.changedProperties); // false, Set([])\r\n\r\nrunInAction(() => schema.prop1++);\r\nconsole.log(schema.isChanged, schema.changedProperties); // true, Set(['prop1'])\r\n\r\nrunInAction(() => schema.prop2++);\r\nconsole.log(schema.isChanged, schema.changedProperties); // true, Set(['prop1', 'prop2'])\r\n\r\nrunInAction(() => schema.prop1--);\r\nconsole.log(schema.isChanged, schema.changedProperties); // true, Set(['prop2'])\r\n"},o={filename:"WatchArraySchema.ts",code:"import { FormSchema, watch } from '@yoskutik/mobx-form-schema';\r\nimport { runInAction } from 'mobx';\r\n\r\nexport class WatchSchema extends FormSchema {\r\n  @watch.array array = [1, 2, 3];\r\n}\r\n\r\nconst schema = WatchSchema.create();\r\nconsole.log(schema.isChanged); // false\r\n\r\nrunInAction(() => schema.array.push(4));\r\nconsole.log(schema.isChanged); // true\r\n\r\nrunInAction(() => schema.array.pop());\r\nconsole.log(schema.isChanged); // false\r\n\r\nrunInAction(() => schema.array = [1, 2, 3]);\r\nconsole.log(schema.isChanged); // false\r\n"},h={filename:"WatchSetSchema.ts",code:"import { FormSchema, watch } from '@yoskutik/mobx-form-schema';\r\nimport { runInAction } from 'mobx';\r\n\r\nexport class WatchSchema extends FormSchema {\r\n  @watch.set array = new Set([1, 2, 3]);\r\n}\r\n\r\nconst schema = WatchSchema.create();\r\nconsole.log(schema.isChanged); // false\r\n\r\nrunInAction(() => schema.array.add(4));\r\nconsole.log(schema.isChanged); // true\r\n\r\nrunInAction(() => schema.array.delete(4));\r\nconsole.log(schema.isChanged); // false\r\n\r\nrunInAction(() => schema.array = new Set([1, 2, 3]));\r\nconsole.log(schema.isChanged); // false\r\n"},s={filename:"WatchNestedSchema.ts",code:"import { FormSchema, watch } from '@yoskutik/mobx-form-schema';\r\nimport { runInAction } from 'mobx';\r\n\r\nclass NestedSchema extends FormSchema {\r\n  @watch prop = 1;\r\n}\r\n\r\nexport class WatchSchema extends FormSchema {\r\n  @watch.schema nestedSchema = NestedSchema.create();\r\n}\r\n\r\nconst schema = WatchSchema.create();\r\nconsole.log(schema.isChanged); // false\r\n\r\nrunInAction(() => schema.nestedSchema.prop++);\r\nconsole.log(schema.isChanged); // true\r\n\r\nrunInAction(() => schema.nestedSchema.prop--);\r\nconsole.log(schema.isChanged); // false\r\n\r\nrunInAction(() => schema.nestedSchema = NestedSchema.create({ prop: 1 }));\r\nconsole.log(schema.isChanged); // false\r\n"},i={filename:"WatchNestedSchemasArray.ts",code:"import { FormSchema, watch } from '@yoskutik/mobx-form-schema';\r\nimport { runInAction } from 'mobx';\r\n\r\nclass NestedSchema extends FormSchema {\r\n  @watch prop = 1;\r\n}\r\n\r\nexport class WatchSchema extends FormSchema {\r\n  @watch.schemasArray nestedSchemas = [NestedSchema.create()];\r\n}\r\n\r\nconst schema = WatchSchema.create();\r\nconsole.log(schema.isChanged); // false\r\n\r\nrunInAction(() => schema.nestedSchemas[0].prop++);\r\nconsole.log(schema.isChanged); // true\r\n\r\nrunInAction(() => schema.nestedSchemas[0].prop--);\r\nconsole.log(schema.isChanged); // false\r\n\r\nrunInAction(() => schema.nestedSchemas = [NestedSchema.create({ prop: 1 })]);\r\nconsole.log(schema.isChanged); // false\r\n"},l={filename:"configure.ts",code:"type FieldOrGetDecoratorWithContext<This, Result> = /* Declared dynamically */ any;\r\n\r\ntype TComparator<This, Value> = (newValue: Value, oldValue: Value, schema: This, key: string) => boolean;\r\ntype TObjectSaveFn<This, Value> = (newValue: Value, schema: This) => void;\r\ntype TRestoreFn<This, Value> = (initialValue: Value, schema: This) => void;\r\n\r\ndeclare function configure<This, Value>(\r\n  comparator: TComparator<This, Value>,\r\n  saveFn: TObjectSaveFn<This, Value>,\r\n  restoreFn: TRestoreFn<This, Value>,\r\n): FieldOrGetDecoratorWithContext<This, Value>;\r\n"},m={filename:"ConfigureSchema.ts",code:"import { FormSchema, watch } from '@yoskutik/mobx-form-schema';\r\nimport { makeObservable, observable, runInAction } from 'mobx';\r\n\r\ntype TData = [number, string];\r\n\r\nconst compareData = (newValue: TData, oldValue: TData) => newValue[0] === oldValue[0];\r\nconst saveDataToInitialState = (data: TData) => [...data];\r\nconst getDataFromInitialState = (data: TData) => [...data];\r\n\r\nconst customDecorator = watch.configure(\r\n  compareData,\r\n  saveDataToInitialState,\r\n  getDataFromInitialState,\r\n);\r\n\r\nexport class ConfigureSchema extends FormSchema {\r\n  @customDecorator data: TData = [0, 'string'];\r\n\r\n  constructor() {\r\n    super();\r\n    makeObservable(this, {\r\n      data: observable.shallow,\r\n    });\r\n  }\r\n}\r\n\r\nconst schema = ConfigureSchema.create();\r\nconsole.log(schema.isChanged); // false\r\n\r\nrunInAction(() => schema.data[0]++);\r\nconsole.log(schema.isChanged); // true\r\n\r\nrunInAction(() => schema.data[0]--);\r\nconsole.log(schema.isChanged); // false\r\n\r\nrunInAction(() => schema.data[1] = 'Any other string');\r\nconsole.log(schema.isChanged); // false\r\n\r\nrunInAction(() => schema.data = [0, 'Literally any other string']);\r\nconsole.log(schema.isChanged); // false\r\n\r\nrunInAction(() => schema.data = [1, 'string']);\r\nconsole.log(schema.isChanged); // true\r\n"},d=a(9928);let u=()=>(0,t.BX)(t.HY,{children:[(0,t.BX)(n.$0,{title:(0,t.BX)(t.HY,{children:["The ",(0,t.tZ)(n.EK,{children:"@watch"})," decorator"]}),children:[(0,t.BX)(n.xv,{children:["With the ",(0,t.tZ)(n.EK,{children:"@watch"})," decorator, you can understand whether your form's current state is different from the initial one. After you use this decorator, you can use the ",(0,t.tZ)(n.EK,{children:"isChanged"})," in order to understand if the entire form is changed and the ",(0,t.tZ)(n.EK,{children:"changedProperties"})," set in order to determine which properties are changed."]}),(0,t.BX)(n.xv,{children:["If you use ",(0,t.tZ)(n.EK,{children:"@watch"})," decorator on a property, MobX Form Schema will mark this property with ",(0,t.tZ)(n.EK,{children:"observable.ref"})," decorator. But if you need any other type of observation, you can use the ",(0,t.tZ)(n.EK,{children:"makeObservable"})," function from MobX and pass the object with properties observation declaration or use MobX' decorators."]}),(0,t.BX)(n.xv,{children:["With the ",(0,t.tZ)(n.EK,{children:"watch"})," decorators, values are checked with their reference (using ",(0,t.tZ)(n.EK,{children:"==="})," comparison). And because of that, the ",(0,t.tZ)(n.EK,{children:"@watch"})," decorator should be mostly used with primitive values."]}),(0,t.tZ)(n.$0,{title:"Example of usage",children:(0,t.tZ)(n.KE,{items:[c]})})]}),(0,t.BX)(n.$0,{title:(0,t.BX)(t.HY,{children:["The ",(0,t.tZ)(n.EK,{children:"@watch.array"})," decorator"]}),children:[(0,t.BX)(n.xv,{children:["The ",(0,t.tZ)(n.EK,{children:"@watch.array"})," is a modification of the ",(0,t.tZ)(n.EK,{children:"@watch"})," decorator, which must be used with arrays."]}),(0,t.BX)(n.xv,{children:["If you use ",(0,t.tZ)(n.EK,{children:"@watch.array"})," decorator on a property, MobX Form Schema will mark this property with ",(0,t.tZ)(n.EK,{children:"observable.shallow"})," decorator, but you can freely overwrite it."]}),(0,t.BX)(n.xv,{children:["With the ",(0,t.tZ)(n.EK,{children:"watch.arrays"}),", values are shallowly compared, which means that every item from the current is compared by reference with the value from the initial state. But if arrays have different lengths, they are automatically considered to be changed."]}),(0,t.tZ)(n.$0,{title:"Example of usage",children:(0,t.tZ)(n.KE,{items:[o]})})]}),(0,t.BX)(n.$0,{title:(0,t.BX)(t.HY,{children:["The ",(0,t.tZ)(n.EK,{children:"@watch.set"})," decorator"]}),children:[(0,t.BX)(n.xv,{children:["The ",(0,t.tZ)(n.EK,{children:"@watch.set"})," is a modification of the ",(0,t.tZ)(n.EK,{children:"@watch"})," decorator, which must be used with sets."]}),(0,t.BX)(n.xv,{children:["If you use ",(0,t.tZ)(n.EK,{children:"@watch.set"})," decorator on a property, MobX Form Schema will mark this property with ",(0,t.tZ)(n.EK,{children:"observable.shallow"})," decorator, but you can freely overwrite it."]}),(0,t.BX)(n.xv,{children:["With the ",(0,t.tZ)(n.EK,{children:"watch.set"}),", values are shallowly compared, which means that every item from the current is compared. But if sets have different sizes, they automatically considered to be changed."]}),(0,t.tZ)(n.$0,{title:"Example of usage",children:(0,t.tZ)(n.KE,{items:[h]})})]}),(0,t.BX)(n.$0,{title:(0,t.BX)(t.HY,{children:["The ",(0,t.tZ)(n.EK,{children:"@watch.schema"})," decorator"]}),children:[(0,t.BX)(n.xv,{children:["The ",(0,t.tZ)(n.EK,{children:"@watch.schema"})," is a modification of the ",(0,t.tZ)(n.EK,{children:"@watch"})," decorator, which must be used with nested form schemas."]}),(0,t.BX)(n.xv,{children:["If you use ",(0,t.tZ)(n.EK,{children:"@watch.schema"})," decorator on a property, MobX Form Schema will mark this property with ",(0,t.tZ)(n.EK,{children:"observable.ref"})," decorator, but you can freely overwrite it."]}),(0,t.BX)(n.xv,{children:["The ",(0,t.tZ)(n.EK,{children:"watch.schema"})," comparison is a bit complex:"]}),(0,t.BX)(n.aV,{children:[(0,t.tZ)("li",{children:"If a nested schema is changed, then the main schema is considered to be changed as well."}),(0,t.tZ)("li",{children:"If a new instance of nested a schema replaces an old one, but it has exact the same initial state and it's not changed, then the main schema is considered to be not changed. Otherwise, the main schema is considered to be changed."})]}),(0,t.tZ)(n.$0,{title:"Example of usage",children:(0,t.tZ)(n.KE,{items:[s]})})]}),(0,t.BX)(n.$0,{title:(0,t.BX)(t.HY,{children:["The ",(0,t.tZ)(n.EK,{children:"@watch.schemasArray"})," decorator"]}),children:[(0,t.BX)(n.xv,{children:["The ",(0,t.tZ)(n.EK,{children:"@watch.schemasArray"})," is a modification of the ",(0,t.tZ)(n.EK,{children:"@watch"})," decorator, which must be used with an array of nested form schemas of the same class."]}),(0,t.BX)(n.xv,{children:["If you use ",(0,t.tZ)(n.EK,{children:"@watch.schemasArray"})," decorator on a property, MobX Form Schema will mark this property with ",(0,t.tZ)(n.EK,{children:"observable.shallow"})," decorator, but you can freely overwrite it."]}),(0,t.BX)(n.xv,{children:["The ",(0,t.tZ)(n.EK,{children:"watch.schemasArray"})," comparison is a mix of the ",(0,t.tZ)(n.EK,{children:"watch.array"})," and the ",(0,t.tZ)(n.EK,{children:"watch.schema"})," comparisons. If arrays have the same length, each schema is compared with the ",(0,t.tZ)(n.EK,{children:"watch.schema"})," comparison. And if all of them is considered not to be changed, then the main schema is also considered not to be changed."]}),(0,t.tZ)(n.$0,{title:"Example of usage",children:(0,t.tZ)(n.KE,{items:[i]})})]}),(0,t.BX)(n.$0,{title:(0,t.BX)(t.HY,{children:["The ",(0,t.tZ)(n.EK,{children:"watch.configure"})," method"]}),children:[(0,t.BX)(n.xv,{children:["The ",(0,t.tZ)(n.EK,{children:"watch.configure"})," allows you to create your own modification of ",(0,t.tZ)(n.EK,{children:"watch"})," decorator. You only have to pass 3 functions:"]}),(0,t.BX)(n.aV,{variant:"ol",children:[(0,t.tZ)("li",{children:"a function that compares values from the current state and the initial one;"}),(0,t.tZ)("li",{children:"a function that saves the current state into the initial one;"}),(0,t.tZ)("li",{children:"a function that restores the value from the initial state."})]}),(0,t.tZ)(n.oP,{className:d.Z.referenceHighlighter,code:l.code}),(0,t.BX)(n.xv,{children:["The ",(0,t.tZ)(n.EK,{children:"watch.configure"})," method creates a separate decorator."]}),(0,t.BX)(n.xv,{children:["If you use the decorator created by the ",(0,t.tZ)(n.EK,{children:"watch.configure"})," on a property, MobX Form Schema will mark this property with ",(0,t.tZ)(n.EK,{children:"observable"})," decorator, but you can freely overwrite it."]}),(0,t.tZ)(n.$0,{title:"Example of usage",children:(0,t.tZ)(n.KE,{items:[m]})})]})]});var f=u}}]);