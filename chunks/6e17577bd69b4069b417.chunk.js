"use strict";(self.webpackChunk_yoskutik_react_vvm_docs=self.webpackChunk_yoskutik_react_vvm_docs||[]).push([[916],{2916:function(e,n,s){s.r(n),s.d(n,{default:function(){return d}});var a=s(2322),o=s(2784),t=s(9730),i=s(8434);let c=()=>(0,a.jsxs)(t.ib,Object.assign({title:"Validation",description:(0,a.jsxs)(i.Z,Object.assign({component:"p"},{children:[(0,a.jsx)("i",{children:"MobX Form Schema"})," does not provide any validation rules out of the box, but you can your own."]}))},{children:[(0,a.jsxs)(t.ib,Object.assign({title:"Usage",description:(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(i.Z,Object.assign({component:"p"},{children:["You can use ",(0,a.jsx)(t.EK,{children:"isValid"})," getter to understand whether all the fields are valid."]})),(0,a.jsxs)(i.Z,Object.assign({component:"p"},{children:["You can use ",(0,a.jsx)(t.EK,{children:"errors"})," getter to get all the errors of the form."]}))]})},{children:[(0,a.jsx)(t.oP,{code:"import { FormSchema, validate, watch } from '@yoskutik/mobx-form-schema';\n\nexport const required = () => (value) => {\n  if (value?.trim()) return false;\n  return 'The field is required';\n};\n\nexport const minLength = (minLength) => (value) => {\n  if (value.length >= minLength) return false;\n  return `The field is supposed to be ${minLength} symbols at least`;\n};\n\nexport class SignUpSchema extends FormSchema {\n  @validate(required(), minLength(8))\n  @watch password = '';\n}"}),(0,a.jsxs)(i.Z,Object.assign({component:"p"},{children:["Each time ",(0,a.jsx)(t.EK,{children:"password"})," is changed, ",(0,a.jsx)(t.EK,{children:"FormSchema"})," will automatically apply the validation."]})),(0,a.jsx)(i.Z,Object.assign({component:"p"},{children:"You can provide several validation rules, in order to separate your validation logic and get an ability to use different validation messages for different rules."})),(0,a.jsx)(t.oP,{code:"const schema = SignUpSchema.create();\n\nconsole.log(\n  schema.password, // ''\n  schema.errors,   // { password: 'The field is required' }\n  schema.isValid,  // false\n);\n\nschema.password = '1234';\nconsole.log(\n  schema.password, // '1234'\n  schema.errors,   // { password: 'The field is supposed to be 8 symbols at least' }\n  schema.isValid,  // false\n);\n\nschema.password = '12345678';\nconsole.log(\n  schema.password, // '12345678'\n  schema.errors,   // {}\n  schema.isValid,  // true\n);"})]})),(0,a.jsxs)(t.ib,Object.assign({title:"Advanced validation",description:(0,a.jsxs)(i.Z,Object.assign({component:"p"},{children:["A ",(0,a.jsx)("i",{children:"validator"})," function can take 2 parameters as an input - the value to validate and the entire schema."]}))},{children:[(0,a.jsx)(t.oP,{code:"import { FormSchema, validate, watch } from '@yoskutik/mobx-form-schema';\nimport { required, minLength } from 'path/to/validators';\n\nexport const repeatedPassword = () => (repeatedPassword, schema) => {\n  if (repeatedPassword === schema.password) return false;\n  return 'Passwords are mismatched';\n};\n\nclass SignUpSchema extends FormSchema {\n  @validate(required(), minLength(8))\n  @watch password = '';\n\n  @validate(required(), repeatedPassword())\n  @watch repeatedPassword = '';\n}"}),(0,a.jsxs)(i.Z,Object.assign({component:"p"},{children:["All the validation applies using MobX's ",(0,a.jsx)(t.EK,{children:"autorun"})," function, which means that in the example of ",(0,a.jsx)(t.EK,{children:"repeatedPassword"})," the validation will be applied not only when ",(0,a.jsx)(t.EK,{children:"repeatedPassword"}),", but also when ",(0,a.jsx)(t.EK,{children:"password"})," is changed as well."]})),(0,a.jsx)(i.Z,Object.assign({component:"p"},{children:"You can provide several validation rules, in order to separate your validation logic and get an ability to use different validation messages for different rules."})),(0,a.jsx)(t.oP,{code:"const schema = SignUpSchema.create();\n\nschema.password = '12345678';\nconsole.log(\n  schema.errors,   // { repeatedPassword: 'Your passwords are mispamatched' }\n  schema.isValid,  // false\n);\n\nschema.repeatedPassword = '12345678';\nconsole.log(\n  schema.errors,   // {}\n  schema.isValid,  // true\n);\n\nschema.password = 'another password';\nconsole.log(\n  schema.errors,   // { repeatedPassword: 'Your passwords are mispamatched' }\n  schema.isValid,  // false\n);"})]})),(0,a.jsxs)(t.ib,Object.assign({title:"Conditional validation",description:(0,a.jsxs)(i.Z,Object.assign({component:"p"},{children:["With ",(0,a.jsx)("i",{children:"MobX Form Schema"})," you can also apply rules to turn off the validation using ",(0,a.jsx)(t.EK,{children:"validate(...).if"})," decorator."]}))},{children:[(0,a.jsx)(t.oP,{code:"import { FormSchema, validate, watch } from '@yoskutik/mobx-form-schema';\nimport { required } from 'path/to/validators';\n\nconst shouldValidateName = (_, schema: SignUpSchema) => (\n  schema.wantToFillInTheName\n);\n\nclass SignUpSchema extends FormSchema {\n  @validate(email()).if(email => !!email) // or simply `.if(Boolean)`\n  @watch email = '';\n\n  @validate(required()).if(shouldValidateName) // or simply `.if(Boolean)`\n  @watch name = '';\n\n  @watch wantToFillInTheName = true;\n}"}),(0,a.jsxs)(i.Z,Object.assign({component:"p"},{children:["In the example above the validation for ",(0,a.jsx)(t.EK,{children:"email"})," will be applied it's not an empty string. This trick is helpful for validating non-required fields."]})),(0,a.jsxs)(i.Z,Object.assign({component:"p"},{children:["The condition of ",(0,a.jsx)(t.EK,{children:"name"})," property is based on the other property of schema. And ",(0,a.jsx)(t.EK,{children:"name"})," will be validated only, when ",(0,a.jsx)(t.EK,{children:"wantToFillInTheName"})," is ",(0,a.jsx)(t.EK,{children:"true"}),"."]})),(0,a.jsx)(t.oP,{code:"const schema = SignUpSchema.create();\n\nconsole.log(schema.errors);\n// { name: 'The field is required' }\n\nschema.wantToFillInTheName = false;\nconsole.log(schema.errors);\n// {}\n\nschema.email = 'not.valid.email';\nconsole.log(schema.errors);\n// { email: 'The email is not valid' }"})]}))]}));var r=s(3007);let l=()=>(0,a.jsxs)(t.ib,Object.assign({title:"Observation",description:(0,a.jsx)(i.Z,Object.assign({component:"p"},{children:"Sometimes it may be useful to understand whether the form is different from the initial state. For example, if we want to disable form submit button, if its content remain the same. And usually, we have to check each field in a form separately."}))},{children:[(0,a.jsxs)(t.ib,Object.assign({title:"Usage",description:(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(i.Z,Object.assign({component:"p"},{children:["But not with ",(0,a.jsx)("i",{children:"MobX Form Schema"}),"! You can simply apply ",(0,a.jsx)(t.EK,{children:"watch"})," decorator for the properties you want to observe for changes from the initial state."]})),(0,a.jsxs)(i.Z,Object.assign({component:"p"},{children:["By default ",(0,a.jsx)(t.EK,{children:"watch"})," applies ",(0,a.jsx)(t.EK,{children:"observable"})," decorator on a property, so instead of using ",(0,a.jsx)(t.EK,{children:"@watch @observable"})," you can just use ",(0,a.jsx)(t.EK,{children:"@watch"}),". But you can freely use it with any other modification of ",(0,a.jsx)(t.EK,{children:"observable"})," decorator, such as ",(0,a.jsx)(t.EK,{children:"observable.ref"})," or ",(0,a.jsx)(t.EK,{children:"observable.shallow"}),"."]}))]})},{children:[(0,a.jsx)(t.oP,{code:"import { FormSchema, watch } from '@yoskutik/mobx-form-schema';\n\nexport class UserSchema extends FormSchema {\n  @watch name = '';\n\n  @watch surname = '';\n}"}),(0,a.jsxs)(i.Z,Object.assign({component:"p"},{children:["And now you can use ",(0,a.jsx)(t.EK,{children:"isChanged"})," getter to know whether any property of the field is changed. And also you can use ",(0,a.jsx)(t.EK,{children:"getInitial"})," method to get the initial value of any property."]})),(0,a.jsx)(i.Z,Object.assign({component:"p"},{children:"You can provide several validation rules, in order to separate your validation logic and get an ability to use different validation messages for different rules."})),(0,a.jsx)(t.oP,{code:"const schema = UserSchema.create();\n\nconsole.log(schema.isChanged) // false\n\nschema.name = 'Name';\nconsole.log(\n  schema.isChanged,           // true\n  schema.getInitial('name'),  // ''\n);\n\nschema.name = '';\nconsole.log(schema.isChanged) // false"}),(0,a.jsx)(i.Z,Object.assign({component:"p"},{children:"And it's even more useful, when the form is pre-filled."})),(0,a.jsx)(t.oP,{code:"const schema = UserSchema.create({\n  name: 'Initial name',\n  surname: 'Initial surname',\n});\n\nconsole.log(\n  schema.isChanged,         // false\n  schema.presentation,      // { name: 'Initial name', surname: 'Initial surname' }\n),\n\n  schema.name = 'Changed name';\nconsole.log(\n  schema.isChanged,           // true\n  schema.getInitial('name'),  // 'Initial name'\n);\n\nschema.name = 'Initial name';\nconsole.log(schema.isChanged) // false"})]})),(0,a.jsxs)(t.ib,Object.assign({title:"Observing non-primitive values",description:(0,a.jsxs)(i.Z,Object.assign({component:"p"},{children:["The ",(0,a.jsx)(t.EK,{children:"watch"})," decorator works well with primitive values, such as numbers, strings, booleans, nulls, undefined, symbols or BigInt. But sometimes it may be useful observing some non-primitive values. To do that, you can use watch's modifiers."]}))},{children:[(0,a.jsx)(t.ib,Object.assign({title:"Observing array of primitives",description:(0,a.jsxs)(i.Z,Object.assign({component:"p"},{children:["If you want to observe an array of primitive values you can use ",(0,a.jsx)(t.EK,{children:"watch.array"})," decorator. And now, even if you pass ",(0,a.jsx)("b",{children:"new"})," array with exact same content, the ",(0,a.jsx)(t.EK,{children:"FormSchema"})," will understand, that it is not changed."]}))},{children:(0,a.jsx)(t.oP,{code:"import { FormSchema, watch } from '@yoskutik/mobx-form-schema';\n\nexport class CVSchema extends FormSchema {\n  @watch.array skills = [];\n}\n\nconst schema = CVFormSchema.create({\n  skills: ['JavaScript', 'HTML'],\n});\n\nconsole.log(schema.isChanged); // false\n\nschema.skills.push('CSS');\nconsole.log(schema.isChanged); // true\n\nschema.skills.pop();\nconsole.log(schema.isChanged); // false\n\n// The array is new, but its content the same as in initial one\nschema.skills = ['JavaScript', 'HTML'];\nconsole.log(schema.isChanged); // false"})})),(0,a.jsx)(t.ib,Object.assign({title:"Observing set of primitives",description:(0,a.jsxs)(i.Z,Object.assign({component:"p"},{children:["If you want to observe a set of primitive values you can use ",(0,a.jsx)(t.EK,{children:"watch.set"})," decorator. And now, even if you pass ",(0,a.jsx)("b",{children:"new"})," set with exact same content, the ",(0,a.jsx)(t.EK,{children:"FormSchema"})," will understand, that it is not changed."]}))},{children:(0,a.jsx)(t.oP,{code:"import { FormSchema, watch } from '@yoskutik/mobx-form-schema';\n\nexport class CVSchema extends FormSchema {\n  @watch.set skills = new Set();\n}\n\nconst schema = CVFormSchema.create({\n  skills: new Set(['JavaScript', 'HTML']),\n});\n\nconsole.log(schema.isChanged); // false\n\nschema.skills.add('CSS');\nconsole.log(schema.isChanged); // true\n\nschema.skills.delete('CSS');\nconsole.log(schema.isChanged); // false\n\n// The set is new, but its content the same as in initial one\nschema.skills = new Set(['JavaScript', 'HTML']);\nconsole.log(schema.isChanged); // false"})})),(0,a.jsx)(t.ib,Object.assign({title:"Observing nested schema",description:(0,a.jsxs)(i.Z,Object.assign({component:"p"},{children:["And you can also have an array of schemas in your schema. In this case you can use ",(0,a.jsx)(t.EK,{children:"watch.schema"})," decorator. And now, even if you pass ",(0,a.jsx)("b",{children:"new"})," array with exact same content, the ",(0,a.jsx)(t.EK,{children:"FormSchema"})," will understand, that it is not changed."]}))},{children:(0,a.jsx)(t.oP,{code:"import { FormSchema, watch } from '@yoskutik/mobx-form-schema';\n\nexport class NestedSchema extends FormSchema {\n  @watch field = 0;\n}\n\nexport class SuperSchema extends FormSchema {\n  @watch.schema nested = NestedSchema.create();\n}\n\nconst schema = SuperSchema.create();\n\nconsole.log(schema.isChanged); // false\n\nschema.nested.field++;\nconsole.log(schema.isChanged); // true\n\nschema.nested.field--;\nconsole.log(schema.isChanged); // false\n\n// The schema is new, but its content the same as in initial one\nschema.nested = NestedSchema.create();\nconsole.log(schema.isChanged); // false"})})),(0,a.jsx)(t.ib,Object.assign({title:"Observing nested schemas array",description:(0,a.jsxs)(i.Z,Object.assign({component:"p"},{children:["You can use one form schema as a property of another one. And when the nested schema is changed, we want to think that parent schema is changed as well. In order to do that you can use ",(0,a.jsx)(t.EK,{children:"watch.schema"})," decorator. And now, even if you pass ",(0,a.jsx)("b",{children:"new"})," schema with exact same content, the ",(0,a.jsx)(t.EK,{children:"FormSchema"})," will understand, that it is not changed."]}))},{children:(0,a.jsx)(t.oP,{code:"import { FormSchema, watch } from '@yoskutik/mobx-form-schema';\n\nexport class NestedSchema extends FormSchema {\n  @watch field = 0;\n}\n\nexport class SuperSchema extends FormSchema {\n  @watch.schema nested = [NestedSchema.create(), NestedSchema.create()];\n}\n\nconst schema = SuperSchema.create();\n\nconsole.log(schema.isChanged); // false\n\nschema.nested[0].field++;\nconsole.log(schema.isChanged); // true\n\nschema.nested[0].field--;\nconsole.log(schema.isChanged); // false\n\n// The array is new, but its content the same as in initial one\nschema.nested = [NestedSchema.create(), NestedSchema.create()];\nconsole.log(schema.isChanged); // false"})})),(0,a.jsx)(t.ib,Object.assign({title:"More advanced observation",description:(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(i.Z,Object.assign({component:"p"},{children:["Basically, ",(0,a.jsx)(t.EK,{children:"watch"}),", ",(0,a.jsx)(t.EK,{children:"watch.set"}),", ",(0,a.jsx)(t.EK,{children:"watch.array"})," "," ",(0,a.jsx)(t.EK,{children:"watch.schema"})," and ",(0,a.jsx)(t.EK,{children:"watch.schemasArray"})," can cover most of your need. But, if you need to use any non-primitive value, you can use ",(0,a.jsx)(t.EK,{children:"watch.configure"})," method to create your own decorator."]})),(0,a.jsx)(r.Z,Object.assign({severity:"info"},{children:"Please make sure that the need for a new decorator is justified. Perhaps if you change your approach, existing decorators will be enough."})),(0,a.jsx)(i.Z,Object.assign({component:"p"},{children:"The example below present observation rule for observing only the second value in the array. That means, that the schema will be considered changed only if the second value is changed."}))]})},{children:(0,a.jsx)(t.oP,{code:"import { FormSchema, watch } from '@yoskutik/mobx-form-schema';\n\nconst customDecorator = watch.configure(\n  (newValue, oldValue) => newValue[1] === oldValue[1],\n  (newValue) => newValue.slice(),\n  (newValue) => newValue.slice(),\n);\n\nexport class Schema extends FormSchema {\n  @customDecorator nested: [string, number] = ['field', 0];\n}\n\nconst schema = Schema.create();\n\nconsole.log(schema.isChanged); // false\n\nschema.nested[0] = 'other value';\nconsole.log(schema.isChanged); // false\n\nschema.nested[1]++;\nconsole.log(schema.isChanged); // true\n\nschema.nested[1]--;\nconsole.log(schema.isChanged); // false\n\n// The array is new, but the second item's content the same as in initial one\nschema.nested = ['', 0];\nconsole.log(schema.isChanged); // false"})}))]}))]})),h=()=>(0,a.jsx)(t.ib,Object.assign({title:"Initialization",description:(0,a.jsxs)(i.Z,Object.assign({component:"p"},{children:["To create an instance of ",(0,a.jsx)("i",{children:"MobX Form Schema"})," you have to call static method ",(0,a.jsx)(t.EK,{children:"create"}),". This method can be called without any data or with a data, that will be used in the initialization process. By default, data from the passed object is applied without any transformations."]}))},{children:(0,a.jsxs)(t.ib,Object.assign({title:"Usage"},{children:[(0,a.jsx)(t.oP,{code:"import { FormSchema } from '@yoskutik/mobx-form-schema';\n\nexport class Schema extends FormSchema {\n  field = 0;\n}\n\nconst schema1 = Schema.create();\nconsole.log(schema1.field);   // 0\n\nconst schema2 = Schema.create({ field: 100 });\nconsole.log(schema1.field);   // 100"}),(0,a.jsx)(t.ib,Object.assign({title:"Initialization with transformations",description:(0,a.jsxs)(i.Z,Object.assign({component:"p"},{children:["But you can use ",(0,a.jsx)(t.EK,{children:"factory"})," decorator to apply a transformation function for the passed data."]}))},{children:(0,a.jsx)(t.oP,{code:"import { presentation, FormSchema } from '@yoskutik/mobx-form-schema';\nimport { format } from 'date-fns';\n\nexport class Schema extends FormSchema {\n  @presentation(value => value.trim())\n  description = '  Description  ';\n\n  @presentation(value => format(value, 'yyyy-MM'))\n  month = new Date();\n\n  name = 'Name';\n}\n\nconst schema = Schema.create();\nconsole.log(schema.presentation);\n// {\n//   description: 'Description',\n//   month: '2023-05',\n//   name: 'Name',\n// }\n\n// But the real values remains the same\nconsole.log(schema.description);  // '  Description  '\nconsole.log(schema.month);        // Fri May 26 2023 00:00:00 GMT+0000 (Eastern European Summer Time)\nconsole.log(schema.name);         // 'Name'"})}))]}))})),m=(0,o.memo)(()=>(0,a.jsxs)(t.LG,{children:[(0,a.jsx)(c,{}),(0,a.jsx)(l,{}),(0,a.jsx)(h,{})]}));var d=m}}]);